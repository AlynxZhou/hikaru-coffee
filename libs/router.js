// Generated by CoffeeScript 2.3.2
(function() {
  var Category, File, Promise, Router, Site, Tag, URL, chokidar, colors, fse, getContentType, getPathFn, getURLFn, getVersion, http, isCurrentPathFn, matchFiles, moment, packageJSON, parseFrontMatter, path, yaml;

  fse = require("fs-extra");

  path = require("path");

  yaml = require("js-yaml");

  http = require("http");

  ({URL} = require("url"));

  colors = require("colors/safe");

  moment = require("moment-timezone");

  chokidar = require("chokidar");

  packageJSON = require("../package.json");

  Promise = require("bluebird");

  ({Site, File, Category, Tag} = require("./types"));

  ({matchFiles, getVersion, getPathFn, getURLFn, getContentType, isCurrentPathFn, parseFrontMatter} = require("./utils"));

  Router = class Router {
    constructor(logger, renderer, processor, generator, translator, site) {
      this.loadFile = this.loadFile.bind(this);
      this.saveFile = this.saveFile.bind(this);
      this.processFile = this.processFile.bind(this);
      this.processPosts = this.processPosts.bind(this);
      this.processPages = this.processPages.bind(this);
      this.saveAssets = this.saveAssets.bind(this);
      this.savePosts = this.savePosts.bind(this);
      this.savePages = this.savePages.bind(this);
      this.saveFiles = this.saveFiles.bind(this);
      this.buildServerRoutes = this.buildServerRoutes.bind(this);
      this.watchAll = this.watchAll.bind(this);
      this.unwatchAll = this.unwatchAll.bind(this);
      this.handleEvents = this.handleEvents.bind(this);
      this.listen = this.listen.bind(this);
      this.build = this.build.bind(this);
      this.serve = this.serve.bind(this);
      this.logger = logger;
      this.renderer = renderer;
      this.processor = processor;
      this.generator = generator;
      this.translator = translator;
      this.site = site;
      this._ = {};
      this.watchers = [];
      this.watchedEvents = [];
      this.sourcePages = [];
      this.handling = false;
      this.getURL = getURLFn(this.site["siteConfig"]["baseURL"], this.site["siteConfig"]["rootDir"]);
      this.getPath = getPathFn(this.site["siteConfig"]["rootDir"]);
      moment.locale(this.site["siteConfig"]["language"]);
    }

    async readFile(file) {
      var raw;
      raw = (await fse.readFile(path.join(file["srcDir"], file["srcPath"])));
      // Auto detect if a file is a binary file or a UTF-8 encoding text file.
      if (raw.equals(Buffer.from(raw.toString("utf8"), "utf8"))) {
        raw = raw.toString("utf8");
      }
      file["text"] = raw;
      file["raw"] = raw;
      return file;
    }

    writeFile(file) {
      if (file["content"] !== file["raw"]) {
        return fse.outputFile(path.join(file["docDir"], file["docPath"]), file["content"]);
      }
      return fse.copy(path.join(file["srcDir"], file["srcPath"]), path.join(file["docDir"], file["docPath"]));
    }

    async loadFile(file) {
      this.logger.debug(`Hikaru is reading \`${colors.cyan(path.join(file["srcDir"], file["srcPath"]))}\`...`);
      file = (await this.readFile(file));
      if (file["srcDir"] === this.site["siteConfig"]["themeSrcDir"]) {
        file = (await this.renderer.render(file));
        if (path.dirname(file["srcPath"]) !== ".") {
          file["type"] = "asset";
          this.site.put("assets", file);
        } else {
          file["type"] = "template";
          this.site["templates"][path.basename(file["srcPath"], path.extname(file["srcPath"]))] = file;
        }
      } else if (file["srcDir"] === this.site["siteConfig"]["srcDir"]) {
        file = parseFrontMatter(file);
        file = (await this.renderer.render(file));
        if (file["text"] !== file["raw"]) {
          if (file["layout"] === "post") {
            file["type"] = "post";
            this.site.put("posts", file);
          } else {
            file["layout"] = file["layout"] || "page";
            file["type"] = "page";
            this.site.put("pages", file);
          }
        } else {
          file["type"] = "asset";
          this.site.put("assets", file);
        }
      }
      return file;
    }

    saveFile(file) {
      this.logger.debug(`Hikaru is writing \`${colors.cyan(path.join(file["docDir"], file["docPath"]))}\`...`);
      return this.writeFile(file);
    }

    async processFile(f) {
      var err, fs, lang, language;
      lang = f["language"] || this.site["siteConfig"]["language"];
      if (!(lang in this.translator.list())) {
        try {
          language = yaml.safeLoad(fse.readFileSync(path.join(this.site["siteConfig"]["themeDir"], "languages", `${lang}.yml`)));
          this.translator.register(lang, language);
        } catch (error) {
          err = error;
          if (err["code"] === "ENOENT") {
            this.logger.warn(`Hikaru cannot find \`${lang}\` language file in your theme.`);
          }
        }
      }
      fs = (await this.processor.process(f, this.site["posts"], {
        "site": this.site.raw(),
        "siteConfig": this.site["siteConfig"],
        "themeConfig": this.site["themeConfig"],
        "moment": moment,
        "getVersion": getVersion,
        "getURL": this.getURL,
        "getPath": this.getPath,
        "isCurrentPath": isCurrentPathFn(this.site["siteConfig"]["rootDir"], f["docPath"]),
        "__": this.translator.getTranslateFn(lang)
      }));
      if (!(fs instanceof Array)) {
        return [fs];
      }
      return fs;
    }

    async processPosts() {
      var i, j, l, len, processed, ps, ref, ref1, results;
      this.site["posts"].sort(function(a, b) {
        return -(a["date"] - b["date"]);
      });
      processed = [];
      ref = this.site["posts"];
      for (j = 0, len = ref.length; j < len; j++) {
        ps = ref[j];
        ps = (await this.processFile(ps));
        processed = processed.concat(ps);
      }
      this.site["posts"] = processed;
      results = [];
      for (i = l = 0, ref1 = this.site["posts"].length; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
        if (i > 0) {
          this.site["posts"][i]["next"] = this.site["posts"][i - 1];
        }
        if (i < this.site["posts"].length - 1) {
          results.push(this.site["posts"][i]["prev"] = this.site["posts"][i + 1]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    async processPages() {
      var j, len, p, ps, ref, results;
      ref = this.site["pages"];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ps = ref[j];
        ps = (await this.processFile(ps));
        results.push((function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = ps.length; l < len1; l++) {
            p = ps[l];
            results1.push(this.site.put("pages", p));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    saveAssets() {
      return this.site["assets"].map((asset) => {
        this.saveFile(asset);
        return asset;
      });
    }

    savePosts() {
      return this.site["posts"].map(async(p) => {
        p["content"] = (await this.site["templates"][p["layout"]]["content"](p));
        this.saveFile(p);
        return p;
      });
    }

    savePages() {
      return this.site["pages"].map(async(p) => {
        if (!(p["layout"] in this.site["templates"])) {
          p["layout"] = "page";
        }
        p["content"] = (await this.site["templates"][p["layout"]]["content"](p));
        this.saveFile(p);
        return p;
      });
    }

    saveFiles() {
      return this.site["files"].map((file) => {
        this.saveFile(file);
        return file;
      });
    }

    buildServerRoutes() {
      var f, j, key, len, ref, results;
      this._ = {};
      ref = this.site["assets"].concat(this.site["posts"]).concat(this.site["pages"]).concat(this.site["files"]);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        key = this.getPath(f["docPath"]);
        this.logger.debug(`Hikaru is serving \`${colors.cyan(key)}\`...`);
        results.push(this._[key] = f);
      }
      return results;
    }

    watchAll() {
      var j, len, ref, results, srcDir;
      ref = [this.site["siteConfig"]["themeSrcDir"], this.site["siteConfig"]["srcDir"]];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        srcDir = ref[j];
        results.push(((srcDir) => {
          var event, l, len1, ref1, results1, watcher;
          watcher = chokidar.watch(path.join("**", "*"), {
            "cwd": srcDir,
            "ignoreInitial": true
          });
          this.watchers.push(watcher);
          ref1 = ["add", "change", "unlink"];
          results1 = [];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            event = ref1[l];
            results1.push(((event) => {
              return watcher.on(event, (srcPath) => {
                var i;
                this.logger.debug(`Hikaru watched event \`${colors.blue(event)}\` from \`${colors.cyan(path.join(srcDir, srcPath))}\``);
                i = this.watchedEvents.findIndex(function(p) {
                  return p["srcDir"] === srcDir && p["srcPath"] === srcPath;
                });
                if (i !== -1) {
                  // Just update event.
                  this.watchedEvents[i]["type"] = event;
                } else {
                  // Not found.
                  this.watchedEvents.push({
                    "type": event,
                    "srcDir": srcDir,
                    "srcPath": srcPath
                  });
                }
                return setImmediate(this.handleEvents);
              });
            })(event));
          }
          return results1;
        })(srcDir));
      }
      return results;
    }

    unwatchAll() {
      var results, w;
      results = [];
      while ((w = this.watchers.shift()) != null) {
        results.push(w.close());
      }
      return results;
    }

    async handleEvents() {
      var e, file, j, k, key, len, ref, ref1, v;
      // Keep handling atomic. Prevent repeatedly handling.
      if (!this.watchedEvents.length || this.handling) {
        return;
      }
      this.handling = true;
      this.site["pages"] = this.sourcePages;
      while ((e = this.watchedEvents.shift()) != null) {
        file = new File(this.site["siteConfig"]["docDir"], e["srcDir"], e["srcPath"]);
        if (e["type"] === "unlink") {
          ref = ["assets", "pages", "posts"];
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            if (this.site.del(key, file) != null) {
              break;
            }
          }
        } else {
          file = (await this.loadFile(file));
          // Templates or assets have relations. Need to reload all of them.
          if (file["type"] === "template") {
            ref1 = this.site["templates"];
            for (k in ref1) {
              v = ref1[k];
              this.site["templates"][k] = (await this.renderer.render(v));
            }
          } else if (file["type"] === "asset") {
            this.site["assets"] = (await Promise.all(this.site["assets"].map((file) => {
              return this.renderer.render(file);
            })));
          }
        }
      }
      this.sourcePages = [...this.site["pages"]];
      this.site = (await this.generator.generate("beforeProcessing", this.site));
      await this.processPosts();
      await this.processPages();
      this.site = (await this.generator.generate("afterProcessing", this.site));
      this.buildServerRoutes();
      return this.handling = false;
    }

    listen(ip, port) {
      var server;
      server = http.createServer(async(request, response) => {
        var res;
        if (!(request["url"] in this._)) {
          this.logger.log(`404: ${request["url"]}`);
          res = this._[this.getPath("404.html")];
          if (res == null) {
            res = {
              "content": `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="\n      width=device-width,\n      initial-scale=1,\n      maximum-scale=1\n    ">\n    <title>404 Not Found</title>\n  </head>\n  <body>\n    <h1>404 Not Found</h1>\n    <p>Hikaru v${packageJSON["version"]}</p>\n  </body>\n</html>`,
              "docPath": this.getPath("404.html")
            };
          }
          response.writeHead(404, {
            "Content-Type": getContentType(res["docPath"])
          });
        } else {
          this.logger.log(`200: ${request["url"]}`);
          res = this._[request["url"]];
          response.writeHead(200, {
            "Content-Type": getContentType(res["docPath"])
          });
        }
        if (res["layout"] != null) {
          if (!(res["layout"] in this.site["templates"])) {
            res["layout"] = "page";
          }
          response.write((await this.site["templates"][res["layout"]]["content"](res)));
        } else {
          response.write(res["content"]);
        }
        return response.end();
      });
      process.prependListener("exit", () => {
        server.close();
        this.logger.log(`Hikaru stopped listening on http://${ip}:${port}${this.getPath()}...`);
        return this.unwatchAll();
      });
      this.logger.log(`Hikaru is listening on http://${ip}:${port}${this.getPath()}...`);
      if (ip !== "localhost") {
        server.listen(port, ip);
      } else {
        server.listen(port);
      }
      return this.watchAll();
    }

    async build() {
      var allFiles;
      allFiles = ((await matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["siteConfig"]["themeSrcDir"]
      }))).map((srcPath) => {
        return new File(this.site["siteConfig"]["docDir"], this.site["siteConfig"]["themeSrcDir"], srcPath);
      }).concat(((await matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["siteConfig"]["srcDir"]
      }))).map((srcPath) => {
        return new File(this.site["siteConfig"]["docDir"], this.site["siteConfig"]["srcDir"], srcPath);
      }));
      await Promise.all(allFiles.map(this.loadFile));
      this.saveAssets();
      this.site = (await this.generator.generate("beforeProcessing", this.site));
      await this.processPosts();
      await this.processPages();
      this.site = (await this.generator.generate("afterProcessing", this.site));
      this.savePosts();
      this.savePages();
      return this.saveFiles();
    }

    async serve(ip, port) {
      var allFiles;
      allFiles = ((await matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["siteConfig"]["themeSrcDir"]
      }))).map((srcPath) => {
        return new File(this.site["siteConfig"]["docDir"], this.site["siteConfig"]["themeSrcDir"], srcPath);
      }).concat(((await matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["siteConfig"]["srcDir"]
      }))).map((srcPath) => {
        return new File(this.site["siteConfig"]["docDir"], this.site["siteConfig"]["srcDir"], srcPath);
      }));
      await Promise.all(allFiles.map(this.loadFile));
      this.sourcePages = [...this.site["pages"]];
      this.site = (await this.generator.generate("beforeProcessing", this.site));
      await this.processPosts();
      await this.processPages();
      this.site = (await this.generator.generate("afterProcessing", this.site));
      this.buildServerRoutes();
      return this.listen(ip, port);
    }

  };

  module.exports = Router;

}).call(this);
