// Generated by CoffeeScript 2.3.1
(function() {
  var Router, colors, dateStrCompare, fm, fse, getAbsPathFn, getUrlFn, glob, isCurrentPathFn, moment, path, yaml;

  path = require("path");

  fm = require("front-matter");

  fse = require("fs-extra");

  yaml = require("js-yaml");

  glob = require("glob");

  colors = require("colors/safe");

  moment = require("moment");

  ({dateStrCompare, getAbsPathFn, getUrlFn, isCurrentPathFn} = require("./utils"));

  module.exports = Router = class Router {
    constructor(logger, renderer, processer, generator, translator, site) {
      this.readData = this.readData.bind(this);
      this.writeData = this.writeData.bind(this);
      this.loadThemeAssets = this.loadThemeAssets.bind(this);
      this.loadTemplates = this.loadTemplates.bind(this);
      this.loadSrcs = this.loadSrcs.bind(this);
      this.renderAssets = this.renderAssets.bind(this);
      this.renderTemplates = this.renderTemplates.bind(this);
      this.renderPosts = this.renderPosts.bind(this);
      this.renderPages = this.renderPages.bind(this);
      this.processP = this.processP.bind(this);
      this.processPosts = this.processPosts.bind(this);
      this.processPages = this.processPages.bind(this);
      this.saveAssets = this.saveAssets.bind(this);
      this.savePosts = this.savePosts.bind(this);
      this.savePages = this.savePages.bind(this);
      this.saveData = this.saveData.bind(this);
      this.route = this.route.bind(this);
      this.logger = logger;
      this.renderer = renderer;
      this.processer = processer;
      this.generator = generator;
      this.translator = translator;
      this.site = site;
      this.getUrl = getUrlFn(this.site["siteConfig"]["baseUrl"], this.site["siteConfig"]["rootDir"]);
      this.getAbsPath = getAbsPathFn(this.site["siteConfig"]["rootDir"]);
    }

    matchFiles(pattern, options) {
      return new Promise(function(resolve, reject) {
        return glob(pattern, options, function(err, res) {
          if (err) {
            return reject(err);
          }
          return resolve(res);
        });
      });
    }

    readData(srcDir, srcPath) {
      this.logger.debug(`Hikaru is reading \`${colors.cyan(path.join(srcDir, srcPath))}\`...`);
      return fse.readFile(path.join(srcDir, srcPath), "utf8").then(function(raw) {
        return {
          "srcPath": srcPath,
          "srcDir": srcDir,
          "text": raw,
          "raw": raw
        };
      });
    }

    writeData(srcDir, data) {
      this.logger.debug(`Hikaru is writing \`${colors.cyan(path.join(this.site["docDir"], data["docPath"]))}\`...`);
      if (data["content"] != null) {
        return fse.outputFile(path.join(this.site["docDir"], data["docPath"]), data["content"]);
      }
      return fse.copy(path.join(srcDir, data["srcPath"]), path.join(this.site["docDir"], data["docPath"]));
    }

    loadThemeAssets() {
      return this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["themeSrcDir"]
      }).then((themeSrcs) => {
        return Promise.all(themeSrcs.filter(function(srcPath) {
          // Asset is in sub dir.
          return path.dirname(srcPath) !== ".";
        }).map((srcPath) => {
          return this.readData(this.site["themeSrcDir"], srcPath).then((data) => {
            return this.site["assets"].push(data);
          });
        }));
      });
    }

    loadTemplates() {
      return this.matchFiles("*", {
        "nodir": true,
        "dot": true,
        "cwd": this.site["themeSrcDir"]
      }).then((templates) => {
        return Promise.all(templates.map((srcPath) => {
          return this.readData(this.site["themeSrcDir"], srcPath).then((data) => {
            data["key"] = path.basename(srcPath, path.extname(srcPath));
            return this.site["templates"][data["key"]] = data;
          });
        }));
      });
    }

    loadSrcs() {
      return this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site["srcDir"]
      }).then((srcs) => {
        return Promise.all(srcs.map((srcPath) => {
          return this.readData(this.site["srcDir"], srcPath).then((data) => {
            var parsed;
            if (typeof data["raw"] === "string") {
              parsed = fm(data["raw"]);
              data["text"] = parsed["body"];
              data = Object.assign(data, parsed["attributes"]);
              if (data["text"] !== data["raw"]) {
                if (data["title"] != null) {
                  data["title"] = data["title"].toString();
                }
                if (data["layout"] === "post") {
                  return this.site["posts"].push(data);
                } else {
                  // Need load templates first.
                  if (!(data["layout"] in this.site["templates"])) {
                    data["layout"] = "page";
                  }
                  return this.site["pages"].push(data);
                }
              } else {
                return this.site["assets"].push(data);
              }
            }
          });
        }));
      });
    }

    renderAssets() {
      return Promise.all(this.site["assets"].map((asset) => {
        return this.renderer.render(asset);
      }));
    }

    renderTemplates() {
      return Promise.all(Object.values(this.site["templates"]).map((template) => {
        return this.renderer.render(template);
      }));
    }

    renderPosts() {
      return Promise.all(this.site["posts"].map((post) => {
        return this.renderer.render(post);
      }));
    }

    renderPages() {
      return Promise.all(this.site["pages"].map((page) => {
        return this.renderer.render(page);
      }));
    }

    async processP(p) {
      var err, lang, language, ps;
      lang = p["language"] || this.site["siteConfig"]["language"];
      if (!(lang in this.translator.list())) {
        try {
          language = yaml.safeLoad(fse.readFileSync(path.join(this.site["themeDir"], "languages", `${lang}.yml`)));
          this.translator.register(lang, language);
        } catch (error) {
          err = error;
          if (err["code"] === "ENOENT") {
            this.logger.info(`Hikaru cannot find \`${lang}\` language file in your theme.`);
          }
        }
      }
      ps = (await this.processer.process(p, this.site["posts"], this.site["templates"], {
        "site": this.site,
        "siteConfig": this.site["siteConfig"],
        "themeConfig": this.site["themeConfig"],
        "moment": moment,
        "getUrl": this.getUrl,
        "getAbsPath": this.getAbsPath,
        "isCurrentPath": isCurrentPathFn(this.site["siteConfig"]["rootDir"], p["docPath"]),
        "__": this.translator.getTranslateFn(lang)
      }));
      if (!(ps instanceof Array)) {
        return [ps];
      }
      return ps;
    }

    async processPosts() {
      var i, j, k, len, p, processed, ref, ref1, results;
      this.site["posts"].sort(dateStrCompare);
      processed = [];
      ref = this.site["posts"];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        p = (await this.processP(p));
        processed = processed.concat(p);
      }
      this.site["posts"] = processed;
      results = [];
      for (i = k = 0, ref1 = this.site["posts"].length; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
        if (i > 0) {
          this.site["posts"][i]["next"] = this.site["posts"][i - 1];
        }
        if (i < this.site["posts"].length - 1) {
          results.push(this.site["posts"][i]["prev"] = this.site["posts"][i + 1]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    async processPages() {
      var j, len, p, processed, ref;
      processed = [];
      ref = this.site["pages"];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        p = (await this.processP(p));
        processed = processed.concat(p);
      }
      return this.site["pages"] = processed;
    }

    saveAssets() {
      return this.site["assets"].map((asset) => {
        this.writeData(asset["srcDir"], asset);
        return asset;
      });
    }

    savePosts() {
      return this.site["posts"].map((post) => {
        this.writeData(post["srcDir"], post);
        return post;
      });
    }

    savePages() {
      return this.site["pages"].map((page) => {
        this.writeData(page["srcDir"], page);
        return page;
      });
    }

    saveData() {
      return this.site["data"].map((data) => {
        this.writeData(null, data);
        return data;
      });
    }

    route() {
      return Promise.all([
        this.loadThemeAssets(),
        this.loadTemplates().then(() => {
          return this.loadSrcs();
        })
      ]).then(() => {
        this.renderAssets().then(() => {
          return this.saveAssets();
        }).catch((err) => {
          this.logger.info("Hikaru catched some error during generating!");
          this.logger.error(err);
          return this.logger.info("Hikaru advise you to check generating files!");
        });
        return Promise.all([this.renderTemplates(), this.renderPages(), this.renderPosts()]);
      }).then(async() => {
        this.site = (await this.generator.generate("beforeProcessing", this.site));
        // processPages() needs to wait for processed posts.
        await this.processPosts();
        await this.processPages();
        // Render post template needs tag and category links,
        // but those links are only generated after processing pages.
        // Maybe change tags and categories routes to a fix path in future.
        this.site["posts"] = (await Promise.all(this.site["posts"].map(async(p) => {
          p["content"] = (await this.site["templates"][p["layout"]]["content"](p));
          return p;
        })));
        this.site["pages"] = (await Promise.all(this.site["pages"].map(async(p) => {
          p["content"] = (await this.site["templates"][p["layout"]]["content"](p));
          return p;
        })));
        this.site = (await this.generator.generate("afterProcessing", this.site));
        this.savePosts();
        this.savePages();
        return this.saveData();
      }).catch((err) => {
        this.logger.info("Hikaru catched some error during generating!");
        this.logger.error(err);
        return this.logger.info("Hikaru advise you to check generating files!");
      });
    }

  };

}).call(this);
