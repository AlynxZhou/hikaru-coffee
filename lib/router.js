// Generated by CoffeeScript 2.3.1
(function() {
  var Promise, Router, URL, chokidar, colors, fse, getAbsPathFn, getContentType, getUrlFn, glob, http, isCurrentPathFn, moment, parseFrontMatter, path, yaml;

  fse = require("fs-extra");

  path = require("path");

  yaml = require("js-yaml");

  glob = require("glob");

  http = require("http");

  ({URL} = require("url"));

  colors = require("colors/safe");

  moment = require("moment");

  chokidar = require("chokidar");

  Promise = require("bluebird");

  ({getAbsPathFn, getUrlFn, getContentType, isCurrentPathFn, parseFrontMatter} = require("./utils"));

  module.exports = Router = class Router {
    constructor(logger, renderer, processer, generator, translator, site) {
      this.readFile = this.readFile.bind(this);
      this.writeFile = this.writeFile.bind(this);
      this.loadFile = this.loadFile.bind(this);
      this.processP = this.processP.bind(this);
      this.processPosts = this.processPosts.bind(this);
      this.processPages = this.processPages.bind(this);
      this.saveAssets = this.saveAssets.bind(this);
      this.savePosts = this.savePosts.bind(this);
      this.savePages = this.savePages.bind(this);
      this.saveFile = this.saveFile.bind(this);
      this.buildServerRoutes = this.buildServerRoutes.bind(this);
      this.generate = this.generate.bind(this);
      this.serve = this.serve.bind(this);
      this.logger = logger;
      this.renderer = renderer;
      this.processer = processer;
      this.generator = generator;
      this.translator = translator;
      this.site = site;
      this._ = {};
      this.getUrl = getUrlFn(this.site.get("siteConfig")["baseUrl"], this.site.get("siteConfig")["rootDir"]);
      this.getAbsPath = getAbsPathFn(this.site.get("siteConfig")["rootDir"]);
      this.srcWatcher = null;
      this.themeWatcher = null;
    }

    matchFiles(pattern, options) {
      return new Promise(function(resolve, reject) {
        return glob(pattern, options, function(err, res) {
          if (err) {
            return reject(err);
          }
          return resolve(res);
        });
      });
    }

    readFile(file) {
      this.logger.debug(`Hikaru is reading \`${colors.cyan(path.join(file["srcDir"], file["srcPath"]))}\`...`);
      return fse.readFile(path.join(file["srcDir"], file["srcPath"])).then((raw) => {
        // Auto detect if a file is a binary file or a UTF-8 encoding text file.
        if (raw.equals(Buffer.from(raw.toString("utf8"), "utf8"))) {
          raw = raw.toString("utf8");
        }
        return {
          "srcPath": file["srcPath"],
          "srcDir": file["srcDir"],
          "docDir": this.site.get("docDir"),
          "text": raw,
          "raw": raw
        };
      });
    }

    writeFile(file) {
      this.logger.debug(`Hikaru is writing \`${colors.cyan(path.join(this.site.get("docDir"), file["docPath"]))}\`...`);
      if (file["content"] !== file["raw"]) {
        return fse.outputFile(path.join(this.site.get("docDir"), file["docPath"]), file["content"]);
      }
      return fse.copy(path.join(file["srcDir"], file["srcPath"]), path.join(this.site.get("docDir"), file["docPath"]));
    }

    async loadFile(file) {
      file = (await this.readFile(file));
      if (file["srcDir"] === this.site.get("themeSrcDir")) {
        file = (await this.renderer.render(file));
        if (path.dirname(file["srcPath"]) !== ".") {
          return this.site.put("assets", file);
        } else {
          return this.site.get("templates")[path.basename(file["srcPath"], path.extname(file["srcPath"]))] = file;
        }
      } else if (file["srcDir"] === this.site.get("srcDir")) {
        file = parseFrontMatter(file);
        file = (await this.renderer.render(file));
        if (file["text"] !== file["raw"]) {
          if (file["layout"] === "post") {
            return this.site.put("posts", file);
          } else {
            file["layout"] = file["layout"] || "page";
            return this.site.put("pages", file);
          }
        } else {
          return this.site.put("assets", file);
        }
      }
    }

    async processP(p) {
      var err, lang, language, ps;
      lang = p["language"] || this.site.get("siteConfig")["language"];
      if (!(lang in this.translator.list())) {
        try {
          language = yaml.safeLoad(fse.readFileSync(path.join(this.site.get("themeDir"), "languages", `${lang}.yml`)));
          this.translator.register(lang, language);
        } catch (error) {
          err = error;
          if (err["code"] === "ENOENT") {
            this.logger.warn(`Hikaru cannot find \`${lang}\` language file in your theme.`);
          }
        }
      }
      ps = (await this.processer.process(p, this.site.get("posts"), {
        "site": this.site.raw(),
        "siteConfig": this.site.get("siteConfig"),
        "themeConfig": this.site.get("themeConfig"),
        "moment": moment,
        "getUrl": this.getUrl,
        "getAbsPath": this.getAbsPath,
        "isCurrentPath": isCurrentPathFn(this.site.get("siteConfig")["rootDir"], p["docPath"]),
        "__": this.translator.getTranslateFn(lang)
      }));
      if (!(ps instanceof Array)) {
        return [ps];
      }
      return ps;
    }

    async processPosts() {
      var i, j, k, len, p, processed, ref, ref1, results;
      this.site.get("posts").sort(function(a, b) {
        return -(a["date"] - b["date"]);
      });
      processed = [];
      ref = this.site.get("posts");
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        p = (await this.processP(p));
        processed = processed.concat(p);
      }
      this.site.set("posts", processed);
      results = [];
      for (i = k = 0, ref1 = this.site.get("posts").length; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
        if (i > 0) {
          this.site.get("posts")[i]["next"] = this.site.get("posts")[i - 1];
        }
        if (i < this.site.get("posts").length - 1) {
          results.push(this.site.get("posts")[i]["prev"] = this.site.get("posts")[i + 1]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    async processPages() {
      var j, len, p, ps, ref, results;
      ref = this.site.get("pages");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ps = ref[j];
        ps = (await this.processP(ps));
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (k = 0, len1 = ps.length; k < len1; k++) {
            p = ps[k];
            results1.push(this.site.put("pages", p));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    saveAssets() {
      return this.site.get("assets").map((asset) => {
        this.writeFile(asset);
        return asset;
      });
    }

    savePosts() {
      return this.site.get("posts").map(async(p) => {
        p["content"] = (await this.site.get("templates")[p["layout"]]["content"](p));
        this.writeFile(p);
        return p;
      });
    }

    savePages() {
      return this.site.get("pages").map(async(p) => {
        if (!(p["layout"] in this.site.get("templates"))) {
          p["layout"] = "page";
        }
        p["content"] = (await this.site.get("templates")[p["layout"]]["content"](p));
        this.writeFile(p);
        return p;
      });
    }

    saveFile() {
      return this.site.get("files").map((file) => {
        this.writeFile(file);
        return file;
      });
    }

    buildServerRoutes() {
      var f, j, key, len, ref, results;
      this._ = {};
      ref = this.site.get("assets").concat(this.site.get("posts")).concat(this.site.get("pages")).concat(this.site.get("files"));
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        key = this.getAbsPath(f["docPath"]);
        this.logger.debug(`Hikaru is building route \`${colors.cyan(key)}\`...`);
        results.push(this._[key] = f);
      }
      return results;
    }

    async generate() {
      var allFiles;
      allFiles = ((await this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site.get("themeSrcDir")
      }))).map((srcPath) => {
        return {
          "srcDir": this.site.get("themeSrcDir"),
          "srcPath": srcPath
        };
      }).concat(((await this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site.get("srcDir")
      }))).map((srcPath) => {
        return {
          "srcDir": this.site.get("srcDir"),
          "srcPath": srcPath
        };
      }));
      await Promise.all(allFiles.map(this.loadFile));
      this.saveAssets();
      this.site = (await this.generator.generate("beforeProcessing", this.site));
      await this.processPosts();
      await this.processPages();
      this.site = (await this.generator.generate("afterProcessing", this.site));
      this.savePosts();
      this.savePages();
      return this.saveFile();
    }

    async serve(ip, port) {
      var allFiles, event, j, k, len, len1, ref, ref1, results, server, unProcessedPages, unProcessedPosts;
      allFiles = ((await this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site.get("themeSrcDir")
      }))).map((srcPath) => {
        return {
          "srcDir": this.site.get("themeSrcDir"),
          "srcPath": srcPath
        };
      }).concat(((await this.matchFiles(path.join("**", "*"), {
        "nodir": true,
        "dot": true,
        "cwd": this.site.get("srcDir")
      }))).map((srcPath) => {
        return {
          "srcDir": this.site.get("srcDir"),
          "srcPath": srcPath
        };
      }));
      await Promise.all(allFiles.map(this.loadFile));
      unProcessedPages = this.site.get("pages").slice(0);
      unProcessedPosts = this.site.get("posts").slice(0);
      this.site = (await this.generator.generate("beforeProcessing", this.site));
      await this.processPosts();
      await this.processPages();
      this.site = (await this.generator.generate("afterProcessing", this.site));
      this.buildServerRoutes();
      server = new http.Server();
      server.on("request", async(request, response) => {
        var res;
        if (!(request["url"] in this._)) {
          this.logger.log(`404: ${request["url"]}`);
          res = this._[this.getAbsPath("404.html")];
          response.writeHead(404, {
            "Content-Type": getContentType(res["docPath"])
          });
        } else {
          this.logger.log(`200: ${request["url"]}`);
          res = this._[request["url"]];
          response.writeHead(200, {
            "Content-Type": getContentType(res["docPath"])
          });
        }
        if (res["layout"] != null) {
          if (!(res["layout"] in this.site.get("templates"))) {
            res["layout"] = "page";
          }
          response.write((await this.site.get("templates")[res["layout"]]["content"](res)));
        } else {
          response.write(res["content"]);
        }
        response.end();
      });
      server.on("close", () => {
        this.themeWatcher.close();
        this.themeWatcher = null;
        this.srcWatcher.close();
        return this.srcWatcher = null;
      });
      this.logger.log(`Hikaru is listening on http://${ip}:${port}${this.getAbsPath()}...`);
      if (ip !== "localhost") {
        server.listen(port, ip);
      } else {
        server.listen(port);
      }
      this.themeWatcher = chokidar.watch(path.join("**", "*"), {
        "cwd": this.site.get("themeSrcDir"),
        "ignoreInitial": true
      });
      ref = ["add", "change", "unlink"];
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        ((event) => {
          return this.themeWatcher.on(event, async(srcPath) => {
            var file, k, key, len1, ref1;
            this.logger.debug(`Hikaru watched event \`${colors.blue(event)}\` from \`${colors.cyan(path.join(this.site.get("themeSrcDir"), srcPath))}\``);
            this.site.set("pages", unProcessedPages);
            this.site.set("posts", unProcessedPosts);
            unProcessedPages = this.site.get("pages").slice(0);
            unProcessedPosts = this.site.get("posts").slice(0);
            file = {
              "srcDir": this.site.get("themeSrcDir"),
              "srcPath": srcPath
            };
            if (event !== "unlink") {
              this.loadFile(file);
            } else {
              ref1 = ["assets", "templates"];
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                key = ref1[k];
                if (this.site.splice(key, file) != null) {
                  break;
                }
              }
            }
            this.site = (await this.generator.generate("beforeProcessing", this.site));
            await this.processPosts();
            await this.processPages();
            this.site = (await this.generator.generate("afterProcessing", this.site));
            return this.buildServerRoutes();
          });
        })(event);
      }
      this.srcWatcher = chokidar.watch(path.join("**", "*"), {
        "cwd": this.site.get("srcDir"),
        "ignoreInitial": true
      });
      ref1 = ["add", "change", "unlink"];
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        event = ref1[k];
        results.push(((event) => {
          return this.srcWatcher.on(event, async(srcPath) => {
            var file, key, l, len2, ref2;
            this.logger.debug(`Hikaru watched event \`${colors.blue(event)}\` from \`${colors.cyan(path.join(this.site.get("srcDir"), srcPath))}\``);
            this.site.set("pages", unProcessedPages);
            this.site.set("posts", unProcessedPosts);
            unProcessedPages = this.site.get("pages").slice(0);
            unProcessedPosts = this.site.get("posts").slice(0);
            file = {
              "srcDir": this.site.get("srcDir"),
              "srcPath": srcPath
            };
            if (event !== "unlink") {
              this.loadFile(file);
            } else {
              ref2 = ["assets", "pages", "posts"];
              for (l = 0, len2 = ref2.length; l < len2; l++) {
                key = ref2[l];
                if (this.site.splice(key, file) != null) {
                  break;
                }
              }
            }
            this.site = (await this.generator.generate("beforeProcessing", this.site));
            await this.processPosts();
            await this.processPages();
            this.site = (await this.generator.generate("afterProcessing", this.site));
            return this.buildServerRoutes();
          });
        })(event));
      }
      return results;
    }

  };

}).call(this);
